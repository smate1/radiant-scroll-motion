import { useState, useEffect, useCallback, useRef } from 'react'
import { supabase } from '@/integrations/supabase/client'

interface ChatMessage {
	id: string
	content: string
	role: 'user' | 'assistant'
	timestamp: Date
}

interface ConnectionState {
	status: 'connecting' | 'connected' | 'disconnected' | 'reconnecting' | 'error'
	lastConnected: Date | null
	retryCount: number
}

const MAX_RETRY_ATTEMPTS = 5
const RETRY_DELAY_BASE = 1000 // 1 second base delay
const SESSION_STORAGE_KEY = 'conexy_chat_session'
const HEARTBEAT_INTERVAL = 30000 // 30 seconds
const CONNECTION_TIMEOUT = 10000 // 10 seconds

// Mock AI responses for demo
const mockResponses = [
	'–î—è–∫—É—é –∑–∞ –≤–∞—à–µ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è! –Ø AI-–∞—Å–∏—Å—Ç–µ–Ω—Ç Connexi —ñ –≥–æ—Ç–æ–≤–∏–π –¥–æ–ø–æ–º–æ–≥—Ç–∏ –≤–∞–º.',
	'–¶–µ –¥—É–∂–µ —Ü—ñ–∫–∞–≤–µ –ø–∏—Ç–∞–Ω–Ω—è! –î–∞–π—Ç–µ –º–µ–Ω—ñ –º–æ–º–µ–Ω—Ç –ø–æ–¥—É–º–∞—Ç–∏ –Ω–∞–¥ –≤—ñ–¥–ø–æ–≤—ñ–¥–¥—é.',
	'–Ø —Ä–æ–∑—É–º—ñ—é –≤–∞—à—É –ø—Ä–æ–±–ª–µ–º—É. –û—Å—å —â–æ —è –º–æ–∂—É –∑–∞–ø—Ä–æ–ø–æ–Ω—É–≤–∞—Ç–∏...',
	'–ß—É–¥–æ–≤–æ! –Ø —Ä–∞–¥–∏–π, —â–æ –º–æ–∂—É –≤–∞–º –¥–æ–ø–æ–º–æ–≥—Ç–∏ –∑ —Ü–∏–º –ø–∏—Ç–∞–Ω–Ω—è–º.',
	'–î–∞–≤–∞–π—Ç–µ —Ä–æ–∑–≥–ª—è–Ω–µ–º–æ —Ü—é —Å–∏—Ç—É–∞—Ü—ñ—é –¥–µ—Ç–∞–ª—å–Ω—ñ—à–µ. –©–æ —Å–∞–º–µ –≤–∞—Å —Ü—ñ–∫–∞–≤–∏—Ç—å?',
	'–¶–µ —Ç–∏–ø–æ–≤–∞ –∑–∞–¥–∞—á–∞, –∑ —è–∫–æ—é –º–∏ —á–∞—Å—Ç–æ —Å—Ç–∏–∫–∞—î–º–æ—Å—è. –û—Å—å —Ä—ñ—à–µ–Ω–Ω—è...',
	'–î—è–∫—É—é –∑–∞ –¥–æ–≤—ñ—Ä—É! –Ø –ø–æ—Å—Ç–∞—Ä–∞—é—Å—è –¥–∞—Ç–∏ –Ω–∞–π–∫—Ä–∞—â—É –≤—ñ–¥–ø–æ–≤—ñ–¥—å.',
	'–í–∞—à–µ –ø–∏—Ç–∞–Ω–Ω—è –¥—É–∂–µ –∞–∫—Ç—É–∞–ª—å–Ω–µ. –û—Å—å —â–æ —è —Ä–µ–∫–æ–º–µ–Ω–¥—É—é...',
]

const getMockResponse = (userMessage: string): string => {
	// Simple logic to generate more relevant responses
	const message = userMessage.toLowerCase()

	if (message.includes('–ø—Ä–∏–≤—ñ—Ç') || message.includes('–∑–¥—Ä–∞–≤—Å—Ç–≤—É–π')) {
		return '–ü—Ä–∏–≤—ñ—Ç! –Ø AI-–∞—Å–∏—Å—Ç–µ–Ω—Ç Connexi. –Ø–∫ —Å–ø—Ä–∞–≤–∏? –ß–∏–º –º–æ–∂—É –¥–æ–ø–æ–º–æ–≥—Ç–∏?'
	}

	if (message.includes('—è–∫ —Å–ø—Ä–∞–≤–∏') || message.includes('—è–∫ –¥–µ–ª–∞')) {
		return '–î—è–∫—É—é, —â–æ –ø–∏—Ç–∞—î—Ç–µ! –£ –º–µ–Ω–µ –≤—Å–µ —á—É–¥–æ–≤–æ. –ì–æ—Ç–æ–≤–∏–π –¥–æ–ø–æ–º–æ–≥—Ç–∏ –≤–∞–º —ñ–∑ –±—É–¥—å-—è–∫–∏–º–∏ –ø–∏—Ç–∞–Ω–Ω—è–º–∏ –ø—Ä–æ –Ω–∞—à—ñ –ø–æ—Å–ª—É–≥–∏.'
	}

	if (message.includes('–¥–æ–ø–æ–º–æ–∂–∏') || message.includes('–¥–æ–ø–æ–º–æ–≥–∞')) {
		return '–ó–≤—ñ—Å–Ω–æ! –Ø —Ç—É—Ç, —â–æ–± –¥–æ–ø–æ–º–æ–≥—Ç–∏. –†–æ–∑–∫–∞–∂—ñ—Ç—å –¥–µ—Ç–∞–ª—å–Ω—ñ—à–µ, —â–æ —Å–∞–º–µ –≤–∞—Å —Ü—ñ–∫–∞–≤–∏—Ç—å?'
	}

	if (
		message.includes('—Ü—ñ–Ω–∞') ||
		message.includes('–≤–∞—Ä—Ç—ñ—Å—Ç—å') ||
		message.includes('—Å–∫—ñ–ª—å–∫–∏')
	) {
		return '–©–æ–¥–æ —Ü—ñ–Ω–æ—É—Ç–≤–æ—Ä–µ–Ω–Ω—è - —É –Ω–∞—Å –¥—É–∂–µ –≥–Ω—É—á–∫—ñ —Ç–∞—Ä–∏—Ñ–∏. –ú–æ–∂—É –ø—ñ–¥–≥–æ—Ç—É–≤–∞—Ç–∏ –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—É –ø—Ä–æ–ø–æ–∑–∏—Ü—ñ—é. –†–æ–∑–∫–∞–∂—ñ—Ç—å –ø—Ä–æ –≤–∞—à –ø—Ä–æ–µ–∫—Ç?'
	}

	if (
		message.includes('–∫–æ–Ω—Ç–∞–∫—Ç') ||
		message.includes('—Ç–µ–ª–µ—Ñ–æ–Ω') ||
		message.includes('email')
	) {
		return '–û—Å—å –Ω–∞—à—ñ –∫–æ–Ω—Ç–∞–∫—Ç–∏:\nüìû +380 XX XXX XX XX\nüìß info@connexi.com.ua\n–ê–±–æ –º–æ–∂–µ–º–æ –ø—Ä–æ–¥–æ–≤–∂–∏—Ç–∏ —Å–ø—ñ–ª–∫—É–≤–∞–Ω–Ω—è —Ç—É—Ç!'
	}

	if (message.includes('–ø–æ—Å–ª—É–≥–∏') || message.includes('—Å–µ—Ä–≤—ñ—Å')) {
		return '–ú–∏ –Ω–∞–¥–∞—î–º–æ —à–∏—Ä–æ–∫–∏–π —Å–ø–µ–∫—Ç—Ä IT-–ø–æ—Å–ª—É–≥: —Ä–æ–∑—Ä–æ–±–∫–∞, –¥–∏–∑–∞–π–Ω, –∫–æ–Ω—Å–∞–ª—Ç–∏–Ω–≥, –ø—ñ–¥—Ç—Ä–∏–º–∫–∞. –©–æ —Å–∞–º–µ –≤–∞—Å —Ü—ñ–∫–∞–≤–∏—Ç—å?'
	}

	// Random response for other messages
	const randomIndex = Math.floor(Math.random() * mockResponses.length)
	return mockResponses[randomIndex]
}

export const useNewChat = () => {
	const [messages, setMessages] = useState<ChatMessage[]>([])
	const [isLoading, setIsLoading] = useState(false)
	const [error, setError] = useState<string | null>(null)
	const [connectionState, setConnectionState] = useState<ConnectionState>({
		status: 'connecting',
		lastConnected: null,
		retryCount: 0,
	})

	const channelRef = useRef<any>(null)
	const retryTimeoutRef = useRef<NodeJS.Timeout | null>(null)
	const heartbeatRef = useRef<NodeJS.Timeout | null>(null)
	const isUnmountedRef = useRef(false)

	// Enhanced chatId with session persistence
	const [chatId] = useState(() => {
		// Try to restore from session storage
		const savedSession = localStorage.getItem(SESSION_STORAGE_KEY)
		if (savedSession) {
			try {
				const parsed = JSON.parse(savedSession)
				if (
					parsed.chatId &&
					parsed.timestamp &&
					Date.now() - parsed.timestamp < 24 * 60 * 60 * 1000
				) {
					console.log('üîÑ Restored chat session:', parsed.chatId)
					return parsed.chatId
				}
			} catch (e) {
				console.warn('Failed to parse saved session')
			}
		}

		// Generate new chatId
		const newChatId = `chat_${Date.now()}_${Math.random()
			.toString(36)
			.substring(2, 8)}`

		// Save to session storage
		localStorage.setItem(
			SESSION_STORAGE_KEY,
			JSON.stringify({
				chatId: newChatId,
				timestamp: Date.now(),
			})
		)

		console.log('üÜï Generated new chat session:', newChatId)
		return newChatId
	})

	// Enhanced send message with mock AI response
	const sendMessage = useCallback(
		async (message: string) => {
			setIsLoading(true)
			setError(null)

			try {
				console.log('üì§ –í—ñ–¥–ø—Ä–∞–≤–∫–∞ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è:', { message, chatId })

				// Check connection before sending
				if (connectionState.status === 'disconnected') {
					throw new Error('–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –ø–æ—Ç–µ—Ä—è–Ω–æ. –ü—ã—Ç–∞–µ–º—Å—è –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è...')
				}

				// Add user message immediately
				const userMessage: ChatMessage = {
					id: `user-${Date.now()}-${Math.random().toString(36).substring(2)}`,
					content: message,
					role: 'user',
					timestamp: new Date(),
				}

				setMessages(prev => [...prev, userMessage])

				// Simulate API delay
				await new Promise(resolve =>
					setTimeout(resolve, 1000 + Math.random() * 2000)
				)

				// Generate mock AI response
				const aiResponse = getMockResponse(message)
				const assistantMessage: ChatMessage = {
					id: `assistant-${Date.now()}-${Math.random()
						.toString(36)
						.substring(2)}`,
					content: aiResponse,
					role: 'assistant',
					timestamp: new Date(),
				}

				setMessages(prev => [...prev, assistantMessage])

				console.log('‚úÖ –ü–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –≤—ñ–¥–ø—Ä–∞–≤–ª–µ–Ω–æ —Ç–∞ –æ—Ç—Ä–∏–º–∞–Ω–æ –≤—ñ–¥–ø–æ–≤—ñ–¥—å')

				// Reset connection state on successful send
				setConnectionState(prev => ({
					...prev,
					status: 'connected',
					lastConnected: new Date(),
					retryCount: 0,
				}))
			} catch (err) {
				console.error('‚ùå –ü–æ–º–∏–ª–∫–∞ –≤—ñ–¥–ø—Ä–∞–≤–∫–∏ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è:', err)

				if (err instanceof Error && err.name === 'AbortError') {
					setError('–ü—Ä–µ–≤—ã—à–µ–Ω–æ –≤—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ.')
					setConnectionState(prev => ({ ...prev, status: 'reconnecting' }))
				} else {
					const errorMessage =
						err instanceof Error ? err.message : '–ù–µ–≤—ñ–¥–æ–º–∞ –ø–æ–º–∏–ª–∫–∞'
					setError(errorMessage)
				}
			} finally {
				setIsLoading(false)
			}
		},
		[chatId, connectionState.status]
	)

	// Enhanced connection establishment (simplified for demo)
	const establishConnection = useCallback(
		async (isReconnect = false) => {
			if (isUnmountedRef.current) return

			console.log(
				`üîó ${
					isReconnect ? '–ü–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ' : '–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ'
				} –¥–µ–º–æ —á–∞—Ç—É –¥–ª—è chatId:`,
				chatId
			)

			// Update connection state
			setConnectionState(prev => ({
				...prev,
				status: isReconnect ? 'reconnecting' : 'connecting',
			}))

			try {
				// Simulate connection delay
				await new Promise(resolve => setTimeout(resolve, 1000))

				// Set connected state
				setConnectionState({
					status: 'connected',
					lastConnected: new Date(),
					retryCount: 0,
				})

				console.log('‚úÖ –î–µ–º–æ —á–∞—Ç –ø—ñ–¥–∫–ª—é—á–µ–Ω–æ')

				// Start heartbeat
				startHeartbeat()

				// Add welcome message for new chats
				if (!isReconnect && messages.length === 0) {
					setTimeout(() => {
						const welcomeMessage: ChatMessage = {
							id: `welcome-${Date.now()}`,
							content:
								'–ü—Ä–∏–≤—ñ—Ç! –Ø AI-–∞—Å–∏—Å—Ç–µ–Ω—Ç Connexi. –ì–æ—Ç–æ–≤–∏–π –≤—ñ–¥–ø–æ–≤—ñ—Å—Ç–∏ –Ω–∞ –≤–∞—à—ñ –ø–∏—Ç–∞–Ω–Ω—è –ø—Ä–æ –Ω–∞—à—ñ –ø–æ—Å–ª—É–≥–∏. –Ø–∫ —Å–ø—Ä–∞–≤–∏?',
							role: 'assistant',
							timestamp: new Date(),
						}
						setMessages([welcomeMessage])
					}, 500)
				}
			} catch (error) {
				console.error("üí• –ü–æ–º–∏–ª–∫–∞ –≤—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—è –∑'—î–¥–Ω–∞–Ω–Ω—è:", error)
				setConnectionState(prev => ({ ...prev, status: 'error' }))
				scheduleReconnect()
			}
		},
		[chatId, messages.length]
	)

	// Heartbeat to detect connection issues
	const startHeartbeat = useCallback(() => {
		if (heartbeatRef.current) {
			clearInterval(heartbeatRef.current)
		}

		heartbeatRef.current = setInterval(() => {
			if (isUnmountedRef.current) return

			const now = new Date()
			setConnectionState(prev => {
				if (
					prev.lastConnected &&
					now.getTime() - prev.lastConnected.getTime() > HEARTBEAT_INTERVAL * 2
				) {
					console.warn('‚ö†Ô∏è Heartbeat timeout detected, reconnecting...')
					scheduleReconnect()
					return { ...prev, status: 'disconnected' }
				}
				return prev
			})
		}, HEARTBEAT_INTERVAL)
	}, [])

	// Schedule reconnection with exponential backoff
	const scheduleReconnect = useCallback(() => {
		if (isUnmountedRef.current) return

		setConnectionState(prev => {
			if (prev.retryCount >= MAX_RETRY_ATTEMPTS) {
				console.error(
					'üö´ –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞ –∫—ñ–ª—å–∫—ñ—Å—Ç—å —Å–ø—Ä–æ–± –ø–µ—Ä–µ–ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è –¥–æ—Å—è–≥–Ω—É—Ç–∞'
				)
				setError("–ù–µ –≤–¥–∞–ª–æ—Å—è –≤—ñ–¥–Ω–æ–≤–∏—Ç–∏ –∑'—î–¥–Ω–∞–Ω–Ω—è. –ü–µ—Ä–µ–∑–∞–≤–∞–Ω—Ç–∞–∂—Ç–µ —Å—Ç–æ—Ä—ñ–Ω–∫—É.")
				return { ...prev, status: 'error' }
			}

			const delay = RETRY_DELAY_BASE * Math.pow(2, prev.retryCount)
			console.log(
				`üîÑ –ü–ª–∞–Ω—É—î–º–æ –ø–µ—Ä–µ–ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è —á–µ—Ä–µ–∑ ${delay}ms (—Å–ø—Ä–æ–±–∞ ${
					prev.retryCount + 1
				})`
			)

			if (retryTimeoutRef.current) {
				clearTimeout(retryTimeoutRef.current)
			}

			retryTimeoutRef.current = setTimeout(() => {
				if (!isUnmountedRef.current) {
					establishConnection(true)
				}
			}, delay)

			return {
				...prev,
				retryCount: prev.retryCount + 1,
				status: 'reconnecting',
			}
		})
	}, [establishConnection])

	// Main connection effect
	useEffect(() => {
		console.log('üöÄ –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è –¥–µ–º–æ —á–∞—Ç—É –¥–ª—è chatId:', chatId)

		// Delay initial connection to avoid race conditions
		const timer = setTimeout(() => {
			if (!isUnmountedRef.current) {
				establishConnection(false)
			}
		}, 500)

		return () => {
			clearTimeout(timer)
		}
	}, [establishConnection])

	// Cleanup effect
	useEffect(() => {
		return () => {
			console.log('üßπ –û—á–∏—â–µ–Ω–Ω—è —Ä–µ—Å—É—Ä—Å—ñ–≤ –¥–µ–º–æ —á–∞—Ç—É')
			isUnmountedRef.current = true

			if (retryTimeoutRef.current) {
				clearTimeout(retryTimeoutRef.current)
			}

			if (heartbeatRef.current) {
				clearInterval(heartbeatRef.current)
			}
		}
	}, [])

	// Auto-reconnect on window focus
	useEffect(() => {
		const handleFocus = () => {
			if (
				connectionState.status === 'disconnected' ||
				connectionState.status === 'error'
			) {
				console.log('üëÅÔ∏è –í—ñ–∫–Ω–æ –æ—Ç—Ä–∏–º–∞–ª–æ —Ñ–æ–∫—É—Å, –ø—Ä–æ–±—É—î–º–æ –ø–µ—Ä–µ–ø—ñ–¥–∫–ª—é—á–∏—Ç–∏—Å—è')
				setConnectionState(prev => ({ ...prev, retryCount: 0 }))
				establishConnection(true)
			}
		}

		window.addEventListener('focus', handleFocus)
		return () => window.removeEventListener('focus', handleFocus)
	}, [connectionState.status, establishConnection])

	const clearError = useCallback(() => {
		setError(null)
	}, [])

	// Manual reconnect function
	const reconnect = useCallback(() => {
		setConnectionState(prev => ({ ...prev, retryCount: 0 }))
		establishConnection(true)
	}, [establishConnection])

	return {
		messages,
		isLoading,
		error,
		sendMessage,
		clearError,
		chatId,
		connectionState,
		reconnect,
	}
}
